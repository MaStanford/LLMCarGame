[
  {
    "title": "Quest completion does not apply faction reputation or control changes",
    "body": "## Problem\n\nWhen a player completes and turns in a quest, XP and cash rewards are granted but **faction reputation and control changes are never applied**. The quest completion screen renders a \"FACTION CHANGES\" header but the section is empty.\n\n## Location\n\n- `car/screens/quest_complete.py` — line 26 has `# TODO: Add reputation and control changes here`\n- `car/game_state.py` — has `faction_reputation` and `faction_control` dicts that are never updated on quest turn-in\n\n## What is needed to close this issue\n\n1. Determine reputation/control deltas per quest (e.g., +10 rep for the quest-giving faction, -5 for the target faction, +5 control for the giver).\n2. Apply those deltas to `game_state.faction_reputation` and `game_state.faction_control` when the quest is turned in.\n3. Display the changes on the `QuestCompleteScreen` under the \"FACTION CHANGES\" header.\n4. Clamp values to valid ranges (reputation: -100 to 100, control: 0 to 100).\n\n## Work involved\n\n- Update `car/screens/quest_complete.py` to calculate and display faction changes.\n- Update quest turn-in logic (likely in `car/logic/quest_logic.py` or the screen's button handler) to mutate `game_state`.\n- Add/update unit tests for reputation and control clamping.\n- Verify the HUD and faction screen reflect the new values after turn-in.",
    "labels": ["bug", "gameplay"]
  },
  {
    "title": "Trigger system only supports dialog type — combat and quest triggers unimplemented",
    "body": "## Problem\n\nThe trigger system in `car/logic/trigger_logic.py` only handles `\"dialog\"` type triggers. Any trigger with type `\"combat\"` or `\"quest\"` is silently ignored.\n\n## Location\n\n- `car/logic/trigger_logic.py` — line 17: `# TODO: Implement other trigger types (combat, quest)`\n\n## What is needed to close this issue\n\n1. Define what `\"combat\"` triggers should do (e.g., spawn a boss encounter, initiate turn-based combat, spawn a wave of enemies).\n2. Define what `\"quest\"` triggers should do (e.g., auto-accept a quest, advance an objective, show a quest dialog).\n3. Implement handlers for both trigger types in `check_triggers()`.\n4. Add at least one example of each trigger type in the world data or quest data so they can be tested.\n\n## Work involved\n\n- Extend `car/logic/trigger_logic.py` with new handler branches.\n- Decide on the trigger data schema for each type (what fields go in `trigger[\"data\"]`).\n- Wire up combat triggers to the combat screen or spawning system.\n- Wire up quest triggers to the quest logic system.\n- Test that triggers fire correctly when the player enters the trigger zone.",
    "labels": ["enhancement", "gameplay"]
  },
  {
    "title": "No validation that LLM-generated quests reference valid game entities",
    "body": "## Problem\n\nWhen the LLM generates a quest, the response is parsed and used directly without checking whether referenced entities (boss names, enemy types, locations, etc.) actually exist in the game. This can lead to quests that reference non-existent bosses, impossible kill-count targets, or invalid delivery destinations.\n\n## Location\n\n- `car/logic/llm_quest_generator.py` — lines 42-77: quest parsing accepts any entity names from the LLM\n- The fallback quest (lines 81-89) also hardcodes \"Scrap King Klaw\" without validation\n\n## What is needed to close this issue\n\n1. After parsing the LLM response, validate that:\n   - `KillBossObjective` boss names map to a spawnable enemy entity or are dynamically created.\n   - `KillCountObjective` entity types exist in the entity registry.\n   - `DeliverPackageObjective` destination cities exist in the world.\n   - `DefendLocationObjective` locations are reachable.\n2. If validation fails, either:\n   - Re-map the invalid reference to the closest valid entity, OR\n   - Reject the quest and use the fallback.\n3. Log a warning when validation remapping occurs.\n\n## Work involved\n\n- Add a validation pass in `llm_quest_generator.py` after JSON parsing.\n- Build a helper that checks entity names against the entity registry (`car/logic/entity_loader.py`).\n- Build a helper that checks city/location names against world data.\n- Add tests with sample LLM outputs containing invalid references.",
    "labels": ["bug", "llm"]
  },
  {
    "title": "Turn-based combat system is too basic — hardcoded hit chances, no tactics",
    "body": "## Problem\n\nThe turn-based combat system (triggered for boss encounters) has hardcoded hit chances (80% player, 70% enemy) and no tactical depth. The enemy AI always attacks, and the player can only fire or flee.\n\n## Location\n\n- `car/logic/combat_logic.py`:\n  - Line 16: `if random.random() < 0.8:  # 80% hit chance` (player)\n  - Line 45: `if random.random() < 0.7:  # 70% hit chance` (enemy)\n  - Line 44 comment: `\"Simple AI: always attack (This will be expanded to use the phase system)\"`\n- `car/screens/combat.py` — the combat screen UI\n\n## What is needed to close this issue\n\n1. Make hit chances dynamic based on player/enemy stats (e.g., weapon accuracy, vehicle handling, level).\n2. Add more player actions beyond fire/flee (e.g., defend/brace, use item, ram, special weapon attack).\n3. Implement enemy AI phases as noted in the code comment — enemies should have different attack patterns.\n4. Factor in weapon modifiers, vehicle stats, and level scaling into damage calculations.\n\n## Work involved\n\n- Refactor `combat_logic.py` to calculate hit chance from entity stats.\n- Add new action types to `player_turn()` and corresponding UI buttons in `combat.py`.\n- Integrate the existing AI phase system (`car/logic/ai_behaviors.py`) into turn-based combat.\n- Balance damage numbers and hit chances across the level range.\n- Update the combat screen to display the new options and show more combat feedback.",
    "labels": ["enhancement", "gameplay"]
  },
  {
    "title": "Save system relies on fragile temp/ directory with relative paths",
    "body": "## Problem\n\nThe save/load system uses a `temp/` directory with relative paths for session state. This is fragile because:\n- Relative paths break if the working directory changes.\n- If `temp/` is deleted or missing between operations, data is silently lost (falls back to defaults).\n- The pattern of clearing and recreating `temp/` on load creates potential data loss if interrupted.\n- Missing files in `temp/` are only logged as warnings, not surfaced to the player.\n\n## Location\n\n- `car/logic/save_load.py`:\n  - Lines 7-8: `TEMP_DIR = \"temp\"` (relative path)\n  - Lines 45-53: Save copies from temp/ to save slot, silently skips missing files\n  - Lines 66-70: Load clears and recreates temp/\n- `car/logic/data_loader.py`:\n  - Lines 8-10: `TEMP_FACTIONS_PATH = \"temp/factions.py\"` etc. (all relative)\n  - Lines 20-23: Falls back to defaults if temp files missing\n\n## What is needed to close this issue\n\n1. Use absolute paths derived from the project root or a user data directory.\n2. Add integrity checks — verify that required files exist in temp/ after load, and warn the player (not just log) if session data is incomplete.\n3. Make the save operation atomic (write to a staging area, then move) to prevent corruption on interruption.\n4. Consider using a single save file (e.g., a JSON or SQLite db) instead of a directory of loose files.\n\n## Work involved\n\n- Refactor `save_load.py` to use `pathlib.Path` with a resolved base directory.\n- Refactor `data_loader.py` to use the same resolved paths.\n- Add a save integrity validation step on load.\n- Add user-facing error messages when save data is corrupted or missing.\n- Test save/load roundtrip, including edge cases (missing files, interrupted saves).",
    "labels": ["bug", "infrastructure"]
  },
  {
    "title": "Duplicate class definitions in car/data/quests.py — dead code and confusion risk",
    "body": "## Problem\n\n`car/data/quests.py` contains **duplicate definitions** of several classes. Python uses the last definition in the file, making the first definitions dead code. This creates confusion for maintainers and a risk of accidentally editing the wrong (unused) definition.\n\n## Duplicated classes\n\n| Class | First (dead) definition | Second (active) definition |\n|-------|------------------------|---------------------------|\n| `KillBossObjective` | Lines 18-26 | Lines 87-108 |\n| `KillCountObjective` | Lines 28-37 | Lines 110-134 |\n| `SurvivalObjective` | Lines 39-55 | Lines 136-170 |\n| `Quest` | Lines 57-85 | Lines 222-301 |\n\nThe first definitions are minimal stubs; the second definitions are complete with `to_dict()`/`from_dict()` serialization.\n\n`DeliverPackageObjective` (line 172) and `DefendLocationObjective` (line 195) are defined only once.\n\n## What is needed to close this issue\n\n1. Remove the first (dead) definitions of `KillBossObjective`, `KillCountObjective`, `SurvivalObjective`, and `Quest` (lines 18-85).\n2. Verify that no imports or references point to the removed code.\n3. Ensure all tests still pass after cleanup.\n\n## Work involved\n\n- Delete lines 18-85 (the stub definitions) from `car/data/quests.py`.\n- Run the game and verify quest creation, acceptance, completion, and save/load still work.\n- Grep for any references to the removed code to make sure nothing breaks.",
    "labels": ["cleanup"]
  }
]
